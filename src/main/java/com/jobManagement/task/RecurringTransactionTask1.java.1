package com.fsit.clarien.recurring.task;

import com.fsit.clarien.recurring.model.JobDetail;
import com.fsit.clarien.recurring.repository.JobDetailRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.JobParametersInvalidException;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.repository.JobExecutionAlreadyRunningException;
import org.springframework.batch.core.repository.JobInstanceAlreadyCompleteException;
import org.springframework.batch.core.repository.JobRestartException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.time.temporal.IsoFields;
import java.util.Date;
import java.util.List;
import java.util.Optional;

@Service
@Log4j2
@RequiredArgsConstructor
public class RecurringTransactionTask1 {



    @Value("${javainuse.rabbitmq.queue}")
    public  String  queueName;

    @Value("${spring.rabbitmq.username}")
    String username;

    @Value("${spring.rabbitmq.password}")
    private String password;
    @Value("${javainuse.rabbitmq.exchange}")
    String exchange;

    @Value("${javainuse.rabbitmq.routingkey}")
    private String routingkey;

    @Autowired
    private ConnectionFactory rabbitConnectionFactory;
    @Autowired
    @Qualifier("emailJob")
    private Job job1;
    @Autowired
    private JobLauncher jobLauncher;



    @Bean
    Queue queue() {
        return new Queue(queueName, true);
    }
    @Bean
    TopicExchange exchange() {
        return new TopicExchange(exchange);
    }
    @Bean
    Binding binding(Queue queue, TopicExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(routingkey);
    }
    @Bean
    RabbitTemplate rabbitTemplate() {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(rabbitConnectionFactory);
        rabbitTemplate.setExchange(exchange);
        rabbitTemplate.setRoutingKey(routingkey);
        rabbitTemplate.setDefaultReceiveQueue(queueName);
        System.out.println("reached rbtm "+rabbitTemplate);
        //   rabbitTemplate.setTaskExecutor(taskExecutor);
        return rabbitTemplate;
    }

      private final JobDetailRepository jobRepository;
    @Autowired
    private ApplicationContext context;
    @Scheduled(cron = "${recurring.task.cron.expression}")
    public void processJobs() {
        Optional<List<JobDetail>> queuedJobs = jobRepository.getQueuedJobs();
        System.out.println("here-----------------------");
        while (!queuedJobs.get().isEmpty()) {
            queuedJobs.get().forEach((qj)-> {
                try {
                    getCurrentExecutionRecords(qj);
                } catch (JobParametersInvalidException e) {
                    e.printStackTrace();
                } catch (JobExecutionAlreadyRunningException e) {
                    e.printStackTrace();
                } catch (JobRestartException e) {
                    e.printStackTrace();
                } catch (JobInstanceAlreadyCompleteException e) {
                    e.printStackTrace();
                }
            });
        }
    }
    private void getCurrentExecutionRecords(JobDetail jd) throws JobParametersInvalidException, JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException {
        if(jd.isExecuteImmediate()) {
            if(jd.getType().equals("EMAIL")) {
                System.out.println("email "+jd.getName());
             //   Job emailJob = context.getBean("emailJob", Job.class);
                System.out.println("emailJob "+job1);
                JobParameters jobParameters = new JobParametersBuilder()
                        .addDate("dateTime", new Date())
                        .toJobParameters();

                jobLauncher.run(job1, new JobParameters());

            }
        }
        Date today = new Date();
        if(jd.getExecutionDate().before(today) || jd.getExecutionDate().equals(today)) {
         //   System.out.println("yet to find handler");
        }
    }
   // @Scheduled(cron = "${recurring.task.cron.expression}")
    /*private void performRecurringTransactions() throws IOException, JobParametersInvalidException, JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException {
        System.out.println("reached here-----------");
        log.debug("Started {}::performRecurringTransactions()", this.getClass().getName());
        RabbitMQItemReader itr = new RabbitMQItemReader(this.rabbitTemplate());
        Message message = itr.read();
        if(message != null) {
            String type = message.getMessageProperties().getHeader("ContentType");
            System.out.print("here msg " + type);
            if(type.equalsIgnoreCase("application/vnd.ms-excel")) {
                System.out.print("is excel file");
                byte[] inputData = message.getBody();
                JobParameters jobParameters = new JobParametersBuilder().toJobParameters();
                System.out.print("true");

                BatchConfiguration.byteArrayResource = new ByteArrayResource(inputData);
                JobExecution jobExecution = jobLauncher.run(job,jobParameters);
                BatchStatus batchStatus = jobExecution.getStatus();

            }
        }


    }*/

    private void processJob(JobDetail job) {

        log.info("Processing Job - {} ", job.getJobId());
/*
        long trxnSerno = 0;
        long trxnPartitionKey = 0;
        String uniqueAccount = null;
        long reqId = th.getReqId();
        String corpId = StringUtils.isNotEmpty(th.getCorpId()) ? th.getCorpId() : th.getUserId();
        String userId = th.getUserId();
        String corpUser = String.format("%s.%s", corpId, userId);
        String payeeId = th.getTransactionReqDetails().getPayeeId();
        String currency = th.getTransactionReqDetails().getCurrency();
        String txnCurrency = th.getTransactionReqDetails().getTxnCurrency();
        BigDecimal amt = th.getTransactionReqDetails().getAmountPaid();
        String accountType = th.getTransactionReqDetails().getTranActEntityType();
        String txnType = getTxnType(accountType);
        String accNo = th.getTransactionReqDetails().getAccNo();
        String branchId =
                Strings.isNotEmpty(th.getTransactionReqDetails().getTranActEntityExtn2())
                        ? th.getTransactionReqDetails().getTranActEntityExtn2()
                        : null;
        String payeeNickname = th.getTransactionReqDetails().getPayeeNickname();
        String channelId = th.getTransactionReqDetails().getChannelId();
        String paymentChannel = th.getTransactionReqDetails().getPaymentChannel();
        String serno = (Strings.isNotEmpty(th.getTransactionReqDetails().getSerno())) ? th.getTransactionReqDetails().getSerno() : null;
        String merchantId = null;
        String status = th.getTransactionReqDetails().getStatus();
        ConsumeLimitResult consumeLimitResult = null;
        try {
            if (status.equalsIgnoreCase(Constants.TxnStatusShortCode.RM_REJECT)) {
                throw new TransactionRejectException("RM rejected transaction");
            }
            log.trace("Check if payee exist found for req_id - {} ", reqId);

            if (status.equalsIgnoreCase(Constants.TxnStatusShortCode.PENDING)) {

              
                BigDecimal amtInHomeCrn =new BigDecimal(1);
                th.setTotalTxnAmtInHomeCurrency(amtInHomeCrn);
                th.getTransactionReqDetails().setLimitAmtInHomeCurrency(amtInHomeCrn);

              
            }

            uniqueAccount = (txnType.equalsIgnoreCase(Constants.TransactionType.TRANSFER)) ? accNo : serno;

            if (accountType.equalsIgnoreCase(Constants.AccountType.CREDIT_CARD)) {
                // TODO: CC

                //                PostTransactionResponse postTransactionResponse =
                //                        creditCardClient
                //                                .postTransaction(
                //                                        uniqueAccount,
                //                                        txnCurrency,
                //                                        amt,
                //                                        reqId,
                //                                        0,
                //                                        0,
                //                                        postType,
                //                                        postReason,
                //                                        true,
                //                                        merchantId,
                //                                        ticket)
                //                                .orElseThrow(
                //                                        () ->
                //                                                new CreditCardTxnFailedException(
                //                                                        Constants.FailedMessage.credit_card_txn_failed));
                //
                //                if (postTransactionResponse.getPostTransactionResult().getResult().getCode() != 0
                //                        || !postTransactionResponse
                //                        .getPostTransactionResult()
                //                        .getResponseCode()
                //                        .equalsIgnoreCase("00")) {
                //                    throw new CreditCardTxnFailedException(
                //                            Strings.isNotEmpty(
                //                                    postTransactionResponse.getPostTransactionResult().getResponseDescription())
                //                                    ? postTransactionResponse.getPostTransactionResult().getResponseDescription()
                //                                    : Constants.FailedMessage.credit_card_txn_failed);
                //                }
                //
                //                trxnSerno = postTransactionResponse.getPostTransactionResult().getTrxnSerno();
                //                trxnPartitionKey = postTransactionResponse.getPostTransactionResult().getTrxnPartitionKey();
            }

            Job payee = payeeRepository
                            .findById(Long.parseLong(payeeId))
                    .orElseThrow(() -> new ResourceNotFoundException("No payee found"));

            String requestId = String.format("%s%s", "Req_" + activeProfile + "_bill_payment_scheduler_", reqId);
            System.out.println("reached here---------");

          //  txndRepo.save(txnd);

            scheduleNxtTxn(th, Constants.TxnStatusShortCode.SUCCESS);
        } catch (TransactionRejectException e) {
            log.warn(StringConstants.ERROR_CREATING_TEXT, reqId, e.getMessage());
            retryTxn(th, e.getMessage(), Constants.TxnStatusShortCode.RM_REJECT);
        } catch (Exception e) {
            log.warn(StringConstants.ERROR_CREATING_TEXT, reqId, e.getMessage());
        }*/
    }

    private void handleFinacleTxnFailure(
            String uniqueAccount,
            String txnCurrency,
            BigDecimal amt,
            String userId,
            Long trxnSerno,
            Long trxnPartitionKey,
            String txnType,
            byte[] ticket,
            String bnfId,
            String error) {

        if (txnType.equalsIgnoreCase("CARD")) {
            log.trace("Reversing credit card transaction for {}", userId);

            // TODO: CC

            //            Optional<PostTransactionResponse> postReverseTransactionResponse =
            //                    creditCardClient.postTransaction(
            //                            uniqueAccount,
            //                            txnCurrency,
            //                            amt,
            //                            trqh.getReqId(),
            //                            trxnSerno,
            //                            trxnPartitionKey,
            //                            revType,
            //                            revReason,
            //                            false,
            //                            bnfId,
            //                            ticket);
            //            if (postReverseTransactionResponse.isPresent()
            //                    && postReverseTransactionResponse.get().getPostTransactionResult().getResult().getCode()
            //                    == 0) {
            //                error = String.format("%s. %s", error, "Credit Card Transaction reverse successfully");
            //            } else {
            //                error = String.format("%s. %s", error, "Could not reverse Credit Card Transaction");
            //            }
        }
       // retryTxn(trqh, error, Constants.TxnStatusShortCode.FAILED);
    }

    private String getStatusMsg(String status) {
        switch (status) {
            case "PEN":
                return "Pending";
            case "SUC":
                return "Success";
            default:
                return "Failed";
        }
    }

    private String getTxnType(String accountType) {
        if (accountType.equals("CCD")) {
            return "CARD";
        }
        return "TRFR";
    }


    private LocalDate getNextTxnDate(LocalDate txnDate, String pmtFreq) {
        LocalDate nxtTxnDate;
        switch (pmtFreq) {
            case "W":
                nxtTxnDate = txnDate.plusWeeks(1);
                break;
            case "M":
                nxtTxnDate = txnDate.plusMonths(1);
                break;
            case "Q":
                nxtTxnDate = txnDate.plusMonths(3);
                break;
            case "HY":
                nxtTxnDate = txnDate.plusMonths(6);
                break;
            case "Y":
                nxtTxnDate = txnDate.plusYears(1);
                break;
            default:
            case "D":
                nxtTxnDate = txnDate.plusDays(1);
                break;
        }
        return nxtTxnDate;
    }

    private Long getTimePeriod(LocalDate startDate, LocalDate endDate, String pmtFreq) {
        long timePeriod;
        switch (pmtFreq) {
            case "D":
                timePeriod = ChronoUnit.DAYS.between(startDate, endDate);
                break;
            case "W":
                timePeriod = ChronoUnit.WEEKS.between(startDate, endDate);
                break;
            case "M":
                timePeriod = ChronoUnit.MONTHS.between(startDate, endDate);
                break;
            case "Q":
                timePeriod = IsoFields.QUARTER_YEARS.between(startDate, endDate);
                break;
            case "HY":
                timePeriod = ChronoUnit.MONTHS.between(startDate, endDate) / 6;
                break;
            case "Y":
                timePeriod = ChronoUnit.YEARS.between(startDate, endDate);
                break;
            default:
                timePeriod = 0L;
                break;
        }
        return timePeriod;
    }


}
